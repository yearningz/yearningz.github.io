---
layout: post
title: 基于神经网络的前端智能化理解
key: 20191119
tags: 前端 神经网络
---   
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


### 示例
1.手写数字识别demo    
![img](/statics/images/20191105/10.png)    
2.吃豆人游戏   
![img](/statics/images/20191105/11.png)    
3.[其他演示](https://tensorflow.google.cn/js/demos)

&emsp;&emsp;举例来说，我想周末去参加一个车展。三个因素设置权重来作出决定：   
1. 天气好吗？    
2. 有没有同伴一起去？    
3. 举办地点交通是否便捷？    

&emsp;&emsp; 三个因素对应三个二进制变量x1、x2和x3，为每个输入值设定一个权重，计算出加权和![img](/statics/images/20191105/13.png) ，若期望大于阈值就去，低于就不去。例如天气权重为6，其他条件为2，阈值设置为4。    
![img](/statics/images/20191105/12.png)    

### 神经网络
一、神经网络结构   
* 人体视觉识别：视觉图像激发光感细胞，不同的视觉激发的光感细胞不同，依据大脑皮层中处理视觉的智能区域将不同信息匹配成同一信息。   
* 神经网络:模仿的是生物中神经元组成的网络。某些神经元的激发促使另一些神经元激发。   
  
&emsp;&emsp;以手写数字识别的例子进行说明：   
&emsp;&emsp;若一个28*28的图片作为输入，表示在网络输入层的784个神经元处，输入了784个代表输入图像各像素的灰度值。这层激活值的图案会让下层的激活值产生某些特殊的图案。
   
![img](/statics/images/20191105/6.png)  
&emsp;&emsp;神经网络核心是通过一层的激活值是通过适当的运算，算出下一层的激活值，再让再下层的产生特殊的图案。最终在输出层得到某种结果。   
   
**感知器（人工神经元）**   
&emsp;&emsp;感知器通过接受几个二进制输入变量,产生一个二进制输出：      
![img](/statics/images/20191105/1.png)    
神经元的输出为0或1，由分配的权重总和小于或大于*阈值*决定。     
![img](/statics/images/20191105/CodeCogsEqn.png)        
有时，即使加权和大于0时，也不需要点亮神经元。故增加概念，感知器的偏置b=-threshould代替，偏置即代表加权和多大值才能让神经元激发有意义。
![img](/statics/images/20191105/3.png) 

引入S型神经元来解决通过权重或偏置的微小改动只引起输出的微小变化。允许输入值为0到1之间中任意值，同时对每一个神经元有权重。  

![img](/statics/images/20191105/4.png)    

logistic/逻辑斯蒂曲线，将无限大的负值接近于0，无限大的正值接近于1，即进行压缩和映射。    
![img](/statics/images/20191105/5.png)    

**多层神经元**   
  784个神经元组成网络第一层，而输出的最后一层是0-9这十个数字,中间层通通称为隐藏层。      
  ![img](/statics/images/20191105/7.png)  
  1. 第一层输入了784个代表输入图像各像素的灰度值。每一个连线上带着一个权重。每一个神经元会计算自己的加权和并加上自己的偏置，再通过sigmoid函数进行压缩映射。
  2. 若第二层有16个神经元，则第一层到第二层需要计算784*16个权重值+16个偏置值。故机器学习的重点在于如何调整这些阈值和开关，使得模型正确地解决问题。   
  3. 上一层的激活值将决定下一层的激活值。
  4. 倒数第二层的神经元可以识别不同的数字的局部内容。   
  ![img](/statics/images/20191105/8.png)  
  4. 最后一层的神经元的值表示系统认为输入的对象对应着哪个数字的可能性。   
  ![img](/statics/images/20191105/9.png)  

  利用线性代数中的矩阵计算进行简化。   
  ![img](/statics/images/20191105/14.png)    
  ![img](/statics/images/20191105/15.png)  
  
  整个识别字母的神经网络可以看作一个函数，输入784个值，输出10个值的函数。其中包括13000个权重参数和偏置参数来修改，同时循环用到矩阵乘法和sigmoid映射运算。
&emsp;&emsp;所有的人工智能任务，都可以转化为抽象元素，一层层的抽丝剥茧，例如语音识别。根据短音节，组成单字，组成短语，组成更加抽象的概念。   

####梯度下降 
  训练数据：手写数字图像及标明了图像上数字是几的标签（MNIST base)。    
  训练成本：错误输出与正确输出的差的平方之和.  
  成本方程：以13000个参数作为输入，找到一个最小值为输出。参数为训练数据。其中通过多变量的微积分公式找出梯度变量，使得成本方程有一个平滑的输出，通过斜率找出局部最小值。     
  ![img](/statics/images/20191105/16.png)    
&emsp;&emsp;反复将一个函数的输入按照负梯度的倍数来输入的过程称为**梯度下降**。
成本函数的梯度代表如何改变权重值和偏差值让成本函数最快地变小，即找到权重最大的参数。  

####反向传播演算
&emsp;&emsp;反向传播的理念是利用所有的期待值，计算最后一层到上一层的改动变化量，影响权重和偏置参数，不断循环，到第一层。对所有的样本进行反向传播，记录下每个样本需要修改的权重与偏置，取平均值，进行参数微调。
  ![img](/statics/images/20191105/17.png)      
  

### TensorFlow.js   
[TensorFlow.js](https://tensorflow.google.cn/js) 是一个 JavaScript 库，用于在浏览器和 Node.js 训练和部署机器学习模型。       
#### 安装    
1. 通过标签       

```
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>   
```   

2. npm或yarn安装     
     
```
npm install @tensorflow/tfjs  
```
或者  

```
yarn add @tensorflow/tfjs
```   

#### 利用TensorFlow.js完成一个线性预测模型     

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
<body>
<div id="output_field"></div>
</body>
<script>
    async function learnLinear() {
        const model = tf.sequential();
        model.add(tf.layers.dense({units:1,inputShape:[1]}));
        model.compile({
            loss:'meanSquaredError',
            optimizer:'sgd'
        });
        const xs = tf.tensor2d([-1,0,1,2,3,4],[6,1]);
        const ys = tf.tensor2d([-3,-1,1,3,5,7],[6,1]);

        await model.fit(xs,ys,{epochs:250});
        document.getElementById('output_field').innerText=
            model.predict(tf.tensor2d([10],[1,1]));
    }
    learnLinear();
</script>
</html>
```

###基于深度学习Web信息抽取与实现
   
### 参考
1.《机器学习实战》
2.《神经网络与深度学习》